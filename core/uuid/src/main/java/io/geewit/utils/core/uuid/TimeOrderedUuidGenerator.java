package io.geewit.utils.core.uuid;

import java.time.Instant;
import java.util.concurrent.atomic.AtomicLong;

import static java.lang.Long.SIZE;

/**
 * Generates monotonically increasing identifiers backed by UUIDv7.
 * <p>
 * The generated identifiers keep the 48-bit Unix epoch timestamp and 16 random
 * bits derived from the UUID so that the numeric values retain the natural
 * ordering of UUIDv7 while still fitting a signed {@code long}.
 */
public final class TimeOrderedUuidGenerator {

    /** Number of random bits preserved from the UUID bits. */
    private static final int RANDOM_BITS = 16;

    /** Number of random bits provided by the UUID most significant bits. */
    private static final int MSB_RANDOM_BITS = 12;

    /** Number of variant bits in the UUID least significant bits. */
    private static final int VARIANT_BITS = 2;

    /** Maximum timestamp that can be represented by UUIDv7 (48 bits). */
    private static final long MAX_TIMESTAMP = (1L << 48) - 1;

    public static final TimeOrderedUuidGenerator INSTANCE = new TimeOrderedUuidGenerator();

    private final AtomicLong lastId = new AtomicLong(Long.MIN_VALUE);

    private TimeOrderedUuidGenerator() {
    }

    /**
     * Generate the next identifier using a time-ordered UUID (UUIDv7).
     *
     * @return a monotonically increasing 64-bit identifier
     */
    public long nextId() {
        while (true) {
            long candidate = extractIdentifier(UuidCreator.getTimeOrderedEpoch());
            long previous = lastId.get();
            long next = candidate > previous ? candidate : previous + 1;
            if (lastId.compareAndSet(previous, next)) {
                return next;
            }
        }
    }

    private static long extractIdentifier(UUID uuid) {
        long mostSigBits = uuid.getMostSignificantBits();
        long leastSigBits = uuid.getLeastSignificantBits();

        // Extract the 48-bit millisecond timestamp from the most significant bits.
        long timestamp = mostSigBits >>> RANDOM_BITS;

        // Preserve the 12 random bits from the UUID MSB (after the version bits).
        long randomHigh = mostSigBits & ((1L << MSB_RANDOM_BITS) - 1);

        // Reuse the high order random bits from the LSB (skipping the variant bits)
        // so we can keep 16 bits of randomness overall and avoid collisions when
        // generating many identifiers within the same millisecond.
        int additionalRandomBits = RANDOM_BITS - MSB_RANDOM_BITS;
        long randomLowMask = (1L << (SIZE - VARIANT_BITS)) - 1; // remove the variant bits
        long randomLow = (leastSigBits & randomLowMask) >>> ((SIZE - VARIANT_BITS) - additionalRandomBits);

        long randomBits = (randomHigh << additionalRandomBits) | randomLow;

        return (timestamp << RANDOM_BITS) | randomBits;
    }

    /**
     * Compute the minimal identifier value for a given instant. This is used to
     * build numeric thresholds that match the identifiers generated by
     * {@link #nextId()}.
     *
     * @param instant the instant to convert, if {@code null} the current system
     *                time is used
     * @return the minimal identifier representing the provided instant
     */
    public long minIdForInstant(Instant instant) {
        long epochMillis = instant != null ? instant.toEpochMilli() : System.currentTimeMillis();
        if (epochMillis < 0) {
            epochMillis = 0;
        } else if (epochMillis > MAX_TIMESTAMP) {
            epochMillis = MAX_TIMESTAMP;
        }
        return epochMillis << RANDOM_BITS;
    }
}
